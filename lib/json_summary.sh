# lib/json_summary.sh
# Build a machine-readable JSON summary from artifacts/
num_or_zero() { case "$1" in ''|*[!0-9]*) echo 0 ;; *) echo "$1" ;; esac }
now_utc() { date -u +%Y-%m-%dT%H:%M:%SZ; }

collect_metrics_from_stdout() {
  local file="$1"
  [ -f "$file" ] || { echo "{}"; return 0; }
  awk -F'METRIC:' '/^METRIC:/{print $2}' "$file" | \
    awk -F'=' '{
      key=$1; sub(/^[ \t]+/,"",key); sub(/[ \t]+$/,"",key);
      $1=""; val=substr($0,2);
      gsub(/^[ \t]+|[ \t]+$/, "", val);
      printf("(%s)=(%s)\n", key, val);
    }' | jq -Rn '
      reduce inputs as $line ({}; ($line | capture("\\((?<k>[^)]*)\\)=\\((?<v>.*)\\)")) as $kv
        | . + {($kv.k): $kv.v})'
}

write_summary_json() {
  local out="$1" results_log="$2" skip_log="$3" rg="$4" location="$5" series_filter="$6" max_parallel="$7"

  local totals_good totals_bad totals_skip
  totals_good=$(grep -c '^GOOD|' "$results_log" 2>/dev/null || echo 0)
  totals_bad=$(grep -c '^BAD|'  "$results_log" 2>/dev/null || echo 0)
  totals_skip=$(wc -l < "$skip_log" 2>/dev/null | tr -d ' ' || echo 0)

  # Base object
  jq -n --arg ts "$(now_utc)" \
        --arg rg "$rg" --arg loc "$location" \
        --arg sf "$series_filter" \
        --argjson mp "$(num_or_zero "$max_parallel")" \
        --argjson good "$(num_or_zero "$totals_good")" \
        --argjson bad  "$(num_or_zero "$totals_bad")" \
        --argjson skip "$(num_or_zero "$totals_skip")" '
    {
      _comments: "Test summary generated by json_summary.sh",
      run: { timestamp: $ts, resource_group: $rg, location: $loc, series_filter: $sf, max_parallel: $mp },
      totals: { GOOD: $good, BAD: $bad, SKIP: $skip },
      results: [], skips: [], metrics: [], vm_rollup: {}
    }' > "$out"

  # Append results
  if [ -f "$results_log" ]; then
    tmp_res="$(mktemp)"
    while IFS= read -r line; do
      printf '%s\n' "$line" | awk -F'|' '{
        status=$1;
        vm=""; test=""; series=""; type=""; size=""; offer=""; sku="";
        for(i=2;i<=NF;i++){
          split($i,a,"=");
          if(a[1]=="vm") vm=a[2];
          else if(a[1]=="test") test=a[2];
          else if(a[1]=="series") series=a[2];
          else if(a[1]=="type") type=a[2];
          else if(a[1]=="size") size=a[2];
          else if(a[1]=="offer") offer=a[2];
          else if(a[1]=="sku") sku=a[2];
        else if(a[1]=="detail") detail=a[2];
      }
      # unescape %7C and %3B if you want â€“ or keep encoded; here we keep as-is
      gsub(/"/, "\\\"", detail);
      printf("{\"status\":\"%s\",\"vm\":\"%s\",\"test\":\"%s\",\"series\":\"%s\",\"type\":\"%s\",\"size\":\"%s\",\"offer\":\"%s\",\"sku\":\"%s\",\"detail\":\"%s\"}\n", status, vm, test, series, type, size, offer, sku, detail);
      }'
    done < "$results_log" | jq -s '.' > "$tmp_res"
    jq --slurpfile arr "$tmp_res" '.results = $arr[0]' "$out" > "$out.tmp" && mv "$out.tmp" "$out"
    rm -f "$tmp_res"
  fi

  # Append skips
  if [ -f "$skip_log" ]; then
    tmp_sk="$(mktemp)"
    while IFS= read -r line; do
      printf '%s\n' "$line" | awk -F'|' '{
        code=$1;
        vm=""; msg=""; series=""; type=""; size=""; offer=""; sku="";
        for(i=2;i<=NF;i++){
          if(index($i,"series=")==1) series=substr($i,8);
          else if(index($i,"type=")==1) type=substr($i,6);
          else if(index($i,"size=")==1) size=substr($i,6);
          else if(index($i,"offer=")==1) offer=substr($i,7);
          else if(index($i,"sku=")==1) sku=substr($i,5);
          else if(index($i,"vm=")==1) vm=substr($i,4);
          else msg=$i;
        }
        gsub(/^ *| *$/,"",msg);
        printf("{\"code\":\"%s\",\"vm\":\"%s\",\"series\":\"%s\",\"type\":\"%s\",\"size\":\"%s\",\"offer\":\"%s\",\"sku\":\"%s\",\"message\":\"%s\"}\n", code, vm, series, type, size, offer, sku, msg);
      }'
    done < "$skip_log" | jq -s '.' > "$tmp_sk"
    jq --slurpfile arr "$tmp_sk" '.skips = $arr[0]' "$out" > "$out.tmp" && mv "$out.tmp" "$out"
    rm -f "$tmp_sk"
  fi

  # Metrics per vm/test + vm rollup
  if [ -d artifacts ]; then
    mapfile -t VMS < <(find artifacts -maxdepth 1 -mindepth 1 -type d -printf "%f\n" | sort)
    metrics_array="[]"
    vm_rollup="{}"
    for vm in "${VMS[@]}"; do
      mapfile -t TESTS < <(find "artifacts/$vm" -maxdepth 1 -mindepth 1 -type d -printf "%f\n" | sort)
      merged='{}'
      for t in "${TESTS[@]}"; do
        f="artifacts/$vm/$t/stdout.log"
        m=$(collect_metrics_from_stdout "$f")
        metrics_array=$(jq -cn --arg vm "$vm" --arg t "$t" --argjson m "$m" \
          --argjson arr "${metrics_array:-[]}" '$arr + [{vm:$vm, test:$t, metrics:$m}]')
        merged=$(jq -cn --argjson A "$merged" --argjson B "$m" '$A + $B')
      done
      vm_rollup=$(jq -cn --arg vm "$vm" --argjson R "${vm_rollup:-{}}" --argjson M "$merged" \
        '$R + {($vm): $M}')
    done
    tmp="$(mktemp)";  jq --argjson arr "${metrics_array:-[]}" '.metrics = $arr' "$out" > "$tmp" && mv "$tmp" "$out"
    tmp="$(mktemp)";  jq --argjson vr  "${vm_rollup:-{}}"  '.vm_rollup = $vr' "$out" > "$tmp" && mv "$tmp" "$out"
  fi
}
